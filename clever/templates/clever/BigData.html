<!DOCTYPE html>
<html lang="en">
{% load staticfiles %}
{% include 'clever/header.html'%}

<link rel="icon" href="{% static 'clever/css/bootstrap.css'%}">
    <script type="text/javascript" src="{% static 'clever/jq/jquery-1.10.2.js' %}"></script>
    <script type="text/javascript" src="{% static 'clever/jq/jquery.min.js' %}"></script>
    <script>
        $(document).ready(function(){
        $(".t1").click(function(){
        $(".p1").show();
        $(".p2").hide();
        $(".p3").hide();
        $(".p4").hide();
        $(".p5").hide();
        $(".p6").hide();
        $(".p7").hide();
        });

        $(".t2").click(function(){
        $(".p1").hide();
        $(".p3").hide();
        $(".p2").show();
        $(".p4").hide();
         $(".p5").hide();
        $(".p6").hide();
        $(".p7").hide();

        });

         $(".t3").click(function(){
        $(".p1").hide();
        $(".p2").hide();
        $(".p3").show();
         $(".p4").hide();
          $(".p5").hide();
        $(".p6").hide();
        $(".p7").hide();
        });

         $(".t4").click(function(){
        $(".p1").hide();
        $(".p2").hide();
        $(".p4").show();
         $(".p3").hide();
          $(".p5").hide();
        $(".p6").hide();
        $(".p7").hide();
        });

         $(".t5").click(function(){
        $(".p1").hide();
        $(".p2").hide();
        $(".p5").show();
         $(".p3").hide();
          $(".p4").hide();
        $(".p6").hide();
        $(".p7").hide();
        });
         $(".t6").click(function(){
        $(".p1").hide();
        $(".p2").hide();
        $(".p6").show();
         $(".p3").hide();
          $(".p5").hide();
        $(".p4").hide();
        $(".p7").hide();
        });
         $(".t7").click(function(){
        $(".p1").hide();
        $(".p2").hide();
        $(".p4").hide();
         $(".p3").hide();
          $(".p5").hide();
        $(".p6").hide();
        $(".p7").show();
        });
        });

    </script>
    <style>

.all
{
border:0px solid;
margin:20px;
background-image:url({% static 'clever/img/core-img/texture.png' %});
background-size: 100% 100%;
height:9000px;
padding: 50px;
}
.bll
{
border:0px solid;
background-size: 100% 100%;
height:1000px;
}

h1 {font-size: 30px;}
h2{font-size: 20px;}


  .s2 {
  width: 340px;
  z-index: 1;
  margin:20px;
  background: #f0f0f0;;
  overflow-x: hidden;
  padding: 16px;
}

  .s2 a {
  padding: 6px 10px 6px 60px;
  font-size: 15px;
  color: #000;;
  display: block;
}

  .s2 a:hover {
 background-color: #555;
  color: white;
}

.main {
  margin-left: 140px; /* Same width as the sidebar + left position in px */
  font-size: 28px; /* Increased text to enable scrolling */
  padding: 0px 10px;
}

@media screen and (max-height: 450px) {
    .s2 {padding-top: 15px;}
    .s2 a {font-size: 18px;}
}
/* Change the link color on hover */
li a:hover {
  background-color: #555;
  color: white;
}
a {
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;

}

a:hover {
  background-color: #ddd;
  color: black;
}

.previous {
  background-color: #f1f1f1;
  color: black;
}

.next {
  background-color: #f1f1f1 ;
  color: black;
}


</style>
<body>

<div class="container-fluid">

<div class="row">
        <div class="col-md-3 bll">
            <div class="s2">
                <h2> Hadoop Big Data Topics</h2>
                <p class="t1">Hadoop-Overview</p>
                <p class="t2">Hadoop-BigData Solution</p>
                <p class="t3">Hadoop-Introduction</p>
                <p class ="t4">Hadoop-Environment Setup</p>
                <p class="t5">Hadoop-HDFS Overview</p>
                <p class="t6">Hadoop-HDFS Operation</p>
                <p class="t7">Hadoop Command Refrence</p>


        </div>
        </div>
       <div class="col-md-6 all" style="border:solid 0px ;">
           <div class="p1" style="border:solid 0px ;height:2500px;">
                <center><h1>Hadoop Big Data Overview</h1></center>
<blockquote>“90% of the world’s data was generated in the last few years.”</blockquote>
<p>Due to the advent of new technologies, devices, and communication means like social networking sites, the amount of data produced by mankind is growing rapidly every year. The amount of data produced by us from the beginning of time till 2003 was 5 billion gigabytes. If you pile up the data in the form of disks it may fill an entire football field. The same amount was created in every two days in <b>2011</b>, and in every ten minutes in <b>2013</b>. This rate is still growing enormously. Though all this information produced is meaningful and can be useful when processed, it is being neglected.</p>
<h2>What is Big Data?</h2>
<p><b>Big data</b> is a collection of large datasets that cannot be processed using traditional computing techniques. It is not a single technique or a tool, rather it has become a complete subject, which involves various tools, technqiues and frameworks.</p>
<h2>What Comes Under Big Data?</h2>
<p>Big data involves the data produced by different devices and applications. Given below are some of the fields that come under the umbrella of Big Data.</p>
<ul class="list">
<li><p><b>Black Box Data</b> &minus; It is a component of helicopter, airplanes, and jets, etc. It captures voices of the flight crew, recordings of microphones and earphones, and the performance information of the aircraft.</p></li>
<li><p><b>Social Media Data</b> &minus; Social media such as Facebook and Twitter hold information and the views posted by millions of people across the globe.</p></li>
<li><p><b>Stock Exchange Data</b> &minus; The stock exchange data holds information about the ‘buy’ and ‘sell’ decisions made on a share of different companies made by the customers.</p></li>
<li><p><b>Power Grid Data</b> &minus; The power grid data holds information consumed by a particular node with respect to a base station.</p></li>
<li><p><b>Transport Data</b> &minus; Transport data includes model, capacity, distance and availability of a vehicle.</p></li>
<li><p><b>Search Engine Data</b> &minus; Search engines retrieve lots of data from different databases.</p></li>
</ul>
<center><img src="{% static 'clever/img/bg-img/bbgg.jpg' %}" alt="Big Data" /></center>
<p>Thus Big Data includes huge volume, high velocity, and extensible variety of data. The data in it will be of three types.</p>
<ul class="list">
<li><p><b>Structured data</b> &minus; Relational data.</p></li>
<li><p><b>Semi Structured data</b> &minus; XML data.</p></li>
<li><p><b>Unstructured data</b> &minus; Word, PDF, Text, Media Logs.</p></li>
</ul>
<h2>Benefits of Big Data</h2>
<ul class="list">
<li><p>Using the information kept in the social network like Facebook, the marketing agencies are learning about the response for their campaigns, promotions, and other advertising mediums.</p></li>
<li><p>Using the information in the social media like preferences and product perception of their consumers, product companies and retail organizations are planning their production.</p></li>
<li><p>Using the data regarding the previous medical history of patients, hospitals are providing better and quick service.</p></li>
</ul>
<h2>Big Data Technologies</h2>
<p>Big data technologies are important in providing more accurate analysis, which may lead to more concrete decision-making resulting in greater operational efficiencies, cost reductions, and reduced risks for the business.</p>
<p>To harness the power of big data, you would require an infrastructure that can manage and process huge volumes of structured and unstructured data in realtime and can protect data privacy and security.</p>
<p>There are various technologies in the market from different vendors including Amazon, IBM, Microsoft, etc., to handle big data. While looking into the technologies that handle big data, we examine the following two classes of technology &minus;</p>
<h3>Operational Big Data</h3>
<p>This include systems like MongoDB that provide operational capabilities for real-time, interactive workloads where data is primarily captured and stored.</p>
<p>NoSQL Big Data systems are designed to take advantage of new cloud computing architectures that have emerged over the past decade to allow massive computations to be run inexpensively and efficiently. This makes operational big data workloads much easier to manage, cheaper, and faster to implement.</p>
<p>Some NoSQL systems can provide insights into patterns and trends based on real-time data with minimal coding and without the need for data scientists and additional infrastructure.</p>
<h3>Analytical Big Data</h3>
<p>These includes systems like Massively Parallel Processing (MPP) database systems and MapReduce that provide analytical capabilities for retrospective and complex analysis that may touch most or all of the data.</p>
<p>MapReduce provides a new method of analyzing data that is complementary to the capabilities provided by SQL, and a system based on MapReduce that can be scaled up from single servers to thousands of high and low end machines.</p>
<p>These two classes of technology are complementary and frequently deployed together.</p>
<h2>Operational vs. Analytical Systems</h2>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th></th>
<th style="text-align:center;">Operational</th>
<th style="text-align:center;">Analytical</th>
</tr>
<tr>
<td>Latency</td>
<td>1 ms - 100 ms</td>
<td>1 min - 100 min</td>
</tr>
<tr>
<td>Concurrency</td>
<td>1000 - 100,000</td>
<td>1 - 10</td>
</tr>
<tr>
<td>Access Pattern</td>
<td>Writes and Reads</td>
<td>Reads</td>
</tr>
<tr>
<td>Queries</td>
<td>Selective</td>
<td>Unselective</td>
</tr>
<tr>
<td>Data Scope</td>
<td>Operational</td>
<td>Retrospective</td>
</tr>
<tr>
<td>End User</td>
<td>Customer</td>
<td>Data Scientist</td>
</tr>
<tr>
<td>Technology</td>
<td>NoSQL</td>
<td>MapReduce, MPP Database</td>
</tr>
</table>
<h2>Big Data Challenges</h2>
<p>The major challenges associated with big data are as follows &minus;</p>
<ul class="list">
<li>Capturing data</b></li>
<li>Curation</li>
<li>Storage</li>
<li>Searching</li>
<li>Sharing</li>
<li>Transfer</li>
<li>Analysis</li>
<li>Presentation</li>
</ul>
<p>To fulfill the above challenges, organizations normally take the help of enterprise servers.</p>
            </div>

            <div class="p2" style="border:solid 0px;height:2500px;display:none">
                <center><h1>Hadoop Big Data Solution</h1></center>
<p>In this approach, an enterprise will have a computer to store and process big data. For storage purpose, the programmers will take the help of their choice of database vendors such as Oracle, IBM, etc. In this approach, the user interacts with the application, which
in turn handles the part of data storage and analysis.</p>
<img src="{% static 'clever/img/bg-img/trad.jpg' %}" alt="Big Data Traditional Approach" />
<h3>Limitation</h3>
<p>This approach works fine with those applications that process less voluminous data that can be accommodated by standard database servers, or up to the limit of the processor that is processing the data. But when it comes to dealing with huge amounts of scalable data, it is a hectic task to process such data through a single database bottleneck.</p>
<h2>Google’s Solution</h2>
<p>Google solved this problem using an algorithm called MapReduce. This algorithm divides the task into small parts and assigns them to many computers, and collects the results from them which when integrated, form the result dataset.</p>
<img src="{% static 'clever/img/bg-img/mapre.jpg' %}" alt="Google MapReduce" />
<h2>Hadoop</h2>
<p>Using the solution provided by Google, <b>Doug Cutting</b> and his team developed an Open Source Project called <b>HADOOP</b>.</p>
<p>Hadoop runs applications using the MapReduce algorithm, where the data is processed in parallel with others. In short, Hadoop is used to develop applications that could perform complete statistical analysis on huge amounts of data.</p>
<img src="{% static 'clever/img/bg-img/hado.jpg' %}" alt="Hadoop Framework" />
<hr />
            </div>
            <div class="p3" style="border:solid 0px;height:2500px;display:none">
                <center><h1>Hadoop Introduction</h1></center>
                <p>Hadoop is an Apache open source framework written in java that allows distributed processing of large datasets across clusters of computers using simple programming models. The Hadoop framework application works in an environment that provides distributed <i>storage</i> and <i>computation</i> across clusters of computers. Hadoop is designed to scale up from single server to thousands of machines, each offering local computation and storage.</p>
<h2>Hadoop Architecture</h2>
<p>At its core, Hadoop has two major layers namely &minus;</p>
<ul class="list">
<li>Processing/Computation layer (MapReduce), and</li>
<li>Storage layer (Hadoop Distributed File System).</li>
</ul>
<img src="{% static 'clever/img/bg-img/had-arc.jpg' %}" alt="Hadoop Architecture" />
<h2>MapReduce</h2>
<p>MapReduce is a parallel programming model for writing distributed applications devised at Google for efficient processing of large amounts of data (multi-terabyte data-sets), on large clusters (thousands of nodes) of commodity hardware in a reliable, fault-tolerant
manner. The MapReduce program runs on Hadoop which is an Apache open-source framework.</p>
<h2>Hadoop Distributed File System</h2>
<p>The Hadoop Distributed File System (HDFS) is based on the Google File System (GFS) and provides a distributed file system that is designed to run on commodity hardware. It has many similarities with existing distributed file systems. However, the differences
from other distributed file systems are significant. It is highly fault-tolerant and is designed to be deployed on low-cost hardware. It provides high throughput access to
application data and is suitable for applications having large datasets.</p>
<p>Apart from the above-mentioned two core components, Hadoop framework also includes the following two modules &minus;</p>
<ul class="list">
<li><p><b>Hadoop Common</b> &minus; These are Java libraries and utilities required by other Hadoop
modules.</p></li>
<li><p><b>Hadoop YARN</b> &minus; This is a framework for job scheduling and cluster resource
management.</p></li>
</ul>
<h2>How Does Hadoop Work?</h2>
<p>It is quite expensive to build bigger servers with heavy configurations that handle large scale processing, but as an alternative, you can tie together many commodity computers with single-CPU, as a single functional distributed system and practically, the clustered machines can read the dataset in parallel and provide a much higher throughput. Moreover, it is cheaper than one high-end server. So this is the first motivational factor behind using Hadoop that it runs across clustered and low-cost machines.</p>
<p>Hadoop runs code across a cluster of computers. This process includes the following core tasks that Hadoop performs &minus;</p>
<ul class="list">
<li><p>Data is initially divided into directories and files. Files are divided into uniform sized blocks of 128M and 64M (preferably 128M).</p></li>
<li><p>These files are then distributed across various cluster nodes for further processing.</p></li>
<li><p>HDFS, being on top of the local file system, supervises the processing.</p></li>
<li><p>Blocks are replicated for handling hardware failure.</p></li>
<li><p>Checking that the code was executed successfully.</p></li>
<li><p>Performing the sort that takes place between the map and reduce stages.</p></li>
<li><p>Sending the sorted data to a certain computer.</p></li>
<li><p>Writing the debugging logs for each job.</p></li>
</ul>
<h2>Advantages of Hadoop</h2>
<ul class="list">
<li><p>Hadoop framework allows the user to quickly write and test distributed systems. It is efficient, and it automatic distributes the data and work across the machines and in turn, utilizes the underlying parallelism of the CPU cores.</p></li>
<li><p>Hadoop does not rely on hardware to provide fault-tolerance and high availability (FTHA), rather Hadoop library itself has been designed to detect and handle failures at the application layer.</p></li>
<li><p>Servers can be added or removed from the cluster dynamically and Hadoop continues to operate without interruption.</p></li>
<li><p>Another big advantage of Hadoop is that apart from being open source, it is compatible on all the platforms since it is Java based.</p></li>
</ul>
        </div>
          <div class="p4" style="border:solid 0px;height:9000px;display:none">
             <center> <h1>Hadoop Environment Setup</h1></center>
<p>Hadoop is supported by GNU/Linux platform and its flavors. Therefore, we have to install a Linux operating system for setting up Hadoop environment. In case you have an OS other than Linux, you can install a Virtualbox software in it and have Linux inside the Virtualbox.</p>
<h2>Pre-installation Setup</h2>
<p>Before installing Hadoop into the Linux environment, we need to set up Linux using <b>ssh</b> (Secure Shell). Follow the steps given below for setting up the Linux environment.</p>
<h3>Creating a User</h3>
<p>At the beginning, it is recommended to create a separate user for Hadoop to isolate Hadoop file system from Unix file system. Follow the steps given below to create a user &minus;</p>
<ul class="list">
<li><p>Open the root using the command “su”.</p></li>
<li><p>Create a user from the root account using the command “useradd username”.</p></li>
<li><p>Now you can open an existing user account using the command “su username”. </p></li>
</ul>
<p>Open the Linux terminal and type the following commands to create a user.</p>
<pre class="result notranslate">
$ su
   password:
# useradd hadoop
# passwd hadoop
   New passwd:
   Retype new passwd
</pre>
<h2>SSH Setup and Key Generation </h2>
<p>SSH setup is required to do different operations on a cluster such as starting, stopping, distributed daemon shell operations. To authenticate different users of Hadoop, it is required to provide public/private key pair for a Hadoop user and share it with different users.</p>
<p>The following commands are used for generating a key value pair using SSH. Copy the public keys form id_rsa.pub to authorized_keys, and provide the owner with read and write permissions to authorized_keys file respectively.</p>
<pre class="result notranslate">
$ ssh-keygen -t rsa
$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
$ chmod 0600 ~/.ssh/authorized_keys
</pre>
<h2>Installing Java</h2>
<p>Java is the main prerequisite for Hadoop. First of all, you should verify the existence of java in your system using the command “java -version”. The syntax of java version command is given below.</p>
<pre class="result notranslate">
$ java -version
</pre>
<p>If everything is in order, it will give you the following output.</p>
<pre class="result notranslate">
java version "1.7.0_71"
Java(TM) SE Runtime Environment (build 1.7.0_71-b13)
Java HotSpot(TM) Client VM (build 25.0-b02, mixed mode)
</pre>
<p>If java is not installed in your system, then follow the steps given below for installing java.</p>
<h3>Step 1</h3>
<p>Download java (JDK &lt;latest version&gt; - X64.tar.gz) by visiting the following link<a target="_blank" rel="nofollow" href="https://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html"> www.oracle.com</a></p>
<p>Then <b>jdk-7u71-linux-x64.tar.gz</b> will be downloaded into your system. </p>
<h3>Step 2</h3>
<p>Generally you will find the downloaded java file in Downloads folder. Verify it and extract the <b>jdk-7u71-linux-x64.gz</b> file using the following commands.</p>
<pre class="result notranslate">
$ cd Downloads/
$ ls
jdk-7u71-linux-x64.gz

$ tar zxf jdk-7u71-linux-x64.gz
$ ls
jdk1.7.0_71   jdk-7u71-linux-x64.gz
</pre>
<h3>Step 3</h3>
<p>To make java available to all the users, you have to move it to the location “/usr/local/”. Open root, and type the following commands.</p>
<pre class="result notranslate">
$ su
password:
# mv jdk1.7.0_71 /usr/local/
# exit
</pre>
<h3>Step 4</h3>
<p>For setting up <b>PATH</b> and <b>JAVA_HOME</b> variables, add the following commands to <b>~/.bashrc</b> file.</p>
<pre class="result notranslate">
export JAVA_HOME=/usr/local/jdk1.7.0_71
export PATH=$PATH:$JAVA_HOME/bin
</pre>
<p>Now apply all the changes into the current running system.</p>
<pre class="result notranslate">
$ source ~/.bashrc
</pre>
<h3>Step 5</h3>
<p>Use the following commands to configure java alternatives &minus;</p>
<pre class="result notranslate">
# alternatives --install /usr/bin/java java usr/local/java/bin/java 2
# alternatives --install /usr/bin/javac javac usr/local/java/bin/javac 2
# alternatives --install /usr/bin/jar jar usr/local/java/bin/jar 2

# alternatives --set java usr/local/java/bin/java
# alternatives --set javac usr/local/java/bin/javac
# alternatives --set jar usr/local/java/bin/jar
</pre>
<p>Now verify the java -version command from the terminal as explained above.</p>
<h2>Downloading Hadoop</h2>
<p>Download and extract Hadoop 2.4.1 from Apache software foundation using the following commands.</p>
<pre class="result notranslate">
$ su
password:
# cd /usr/local
# wget http://apache.claz.org/hadoop/common/hadoop-2.4.1/
hadoop-2.4.1.tar.gz
# tar xzf hadoop-2.4.1.tar.gz
# mv hadoop-2.4.1/* to hadoop/
# exit
</pre>
<h2>Hadoop Operation Modes</h2>
<p>Once you have downloaded Hadoop, you can operate your Hadoop cluster in one of the three supported modes &minus;</p>
<ul class="list">
<li><p><b>Local/Standalone Mode</b> &minus; After downloading Hadoop in your system, by default, it is configured in a standalone mode and can be run as a single java process.</p></li>
<li><p><b>Pseudo Distributed Mode</b> &minus; It is a distributed simulation on single machine. Each Hadoop daemon such as hdfs, yarn, MapReduce etc., will run as a separate java process. This mode is useful for development.</p></li>
<li><p><b>Fully Distributed Mode</b> &minus; This mode is fully distributed with minimum two or more machines as a cluster. We will come across this mode in detail in the coming chapters.</p></li>
</ul>
<h2>Installing Hadoop in Standalone Mode</h2>
<p>Here we will discuss the installation of <b>Hadoop 2.4.1</b> in standalone mode.</p>
<p>There are no daemons running and everything runs in a single JVM. Standalone mode is suitable for running MapReduce programs during development, since it is easy to test and debug them.</p>
<h3>Setting Up Hadoop</h3>
<p>You can set Hadoop environment variables by appending the following commands to <b>~/.bashrc</b> file.</p>
<pre class="result notranslate">
export HADOOP_HOME=/usr/local/hadoop
</pre>
<p>Before proceeding further, you need to make sure that Hadoop is working fine. Just issue the following command &minus;</p>
<pre class="result notranslate">
$ hadoop version
</pre>
<p>If everything is fine with your setup, then you should see the following result &minus;</p>
<pre class="result notranslate">
Hadoop 2.4.1
Subversion https://svn.apache.org/repos/asf/hadoop/common -r 1529768
Compiled by hortonmu on 2013-10-07T06:28Z
Compiled with protoc 2.5.0
From source with checksum 79e53ce7994d1628b240f09af91e1af4
</pre>
<p>It means your Hadoop's standalone mode setup is working fine. By default, Hadoop is configured to run in a non-distributed mode on a single machine.</p>
<h3>Example</h3>
<p>Let's check a simple example of Hadoop. Hadoop installation delivers the following example MapReduce jar file, which provides basic functionality of MapReduce and can be used for calculating, like Pi value, word counts in a given list of files, etc.</p>
<pre class="result notranslate">
$HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar
</pre>
<p>Let's have an input directory where we will push a few files and our requirement is to count the total number of words in those files. To calculate the total number of words, we do not need to write our MapReduce, provided the .jar file contains the implementation for word count. You can try other examples using the same .jar file; just issue the following commands to check supported MapReduce functional programs by hadoop-mapreduce-examples-2.2.0.jar file.</p>
<pre class="result notranslate">
$ hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduceexamples-2.2.0.jar
</pre>
<h3>Step 1</h3>
<p>Create temporary content files in the input directory. You can create this input directory anywhere you would like to work.</p>
<pre class="result notranslate">
$ mkdir input
$ cp $HADOOP_HOME/*.txt input
$ ls -l input
</pre>
<p>It will give the following files in your input directory &minus;</p>
<pre class="result notranslate">
total 24
-rw-r--r-- 1 root root 15164 Feb 21 10:14 LICENSE.txt
-rw-r--r-- 1 root root   101 Feb 21 10:14 NOTICE.txt
-rw-r--r-- 1 root root  1366 Feb 21 10:14 README.txt
</pre>
<p>These files have been copied from the Hadoop installation home directory. For your experiment, you can have different and large sets of files.</p>
<h3>Step 2</h3>
<p>Let's start the Hadoop process to count the total number of words in all the files available in the input directory, as follows &minus;</p>
<pre class="result notranslate">
$ hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduceexamples-2.2.0.jar  wordcount input output
</pre>
<h3>Step 3</h3>
<p>Step-2 will do the required processing and save the output in output/part-r00000 file, which you can check by using &minus;</p>
<pre class="result notranslate">
$cat output/*
</pre>
<p>It will list down all the words along with their total counts available in all the files available in the input directory.</p>
<pre class="result notranslate">
"AS      4
"Contribution" 1
"Contributor" 1
"Derivative 1
"Legal 1
"License"      1
"License");     1
"Licensor"      1
"NOTICE”        1
"Not      1
"Object"        1
"Source”        1
"Work”    1
"You"     1
"Your")   1
"[]"      1
"control"       1
"printed        1
"submitted"     1
(50%)     1
(BIS),    1
(C)       1
(Don't)   1
(ECCN)    1
(INCLUDING      2
(INCLUDING,     2
.............
</pre>
<h2>Installing Hadoop in Pseudo Distributed Mode</h2>
<p>Follow the steps given below to install Hadoop 2.4.1 in pseudo distributed mode.</p>
<h3>Step 1 &minus; Setting Up Hadoop</h3>
<p>You can set Hadoop environment variables by appending the following commands to <b>~/.bashrc</b> file.</p>
<pre class="result notranslate">
export HADOOP_HOME=/usr/local/hadoop
export HADOOP_MAPRED_HOME=$HADOOP_HOME
export HADOOP_COMMON_HOME=$HADOOP_HOME

export HADOOP_HDFS_HOME=$HADOOP_HOME
export YARN_HOME=$HADOOP_HOME
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native
export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin
export HADOOP_INSTALL=$HADOOP_HOME
</pre>
<p>Now apply all the changes into the current running system.</p>
<pre class="result notranslate">
$ source ~/.bashrc
</pre>
<h3>Step 2 &minus; Hadoop Configuration</h3>
<p>You can find all the Hadoop configuration files in the location “$HADOOP_HOME/etc/hadoop”. It is required to make changes in those configuration files according to your Hadoop infrastructure.</p>
<pre class="result notranslate">
$ cd $HADOOP_HOME/etc/hadoop
</pre>
<p>In order to develop Hadoop programs in java, you have to reset the java environment variables in <b>hadoop-env.sh</b> file by replacing <b>JAVA_HOME</b> value with the location of java in your system.</p>
<pre class="result notranslate">
export JAVA_HOME=/usr/local/jdk1.7.0_71
</pre>
<p>The following are the list of files that you have to edit to configure Hadoop. </p>
<p><b>core-site.xml</b></p>
<p>The <b>core-site.xml</b> file contains information such as the port number used for Hadoop instance, memory allocated for the file system, memory limit for storing the data, and size of Read/Write buffers.</p>
<p>Open the core-site.xml and add the following properties in between &lt;configuration&gt;, &lt;/configuration&gt; tags.</p>
<pre class="result notranslate">
&lt;configuration&gt;
   &lt;property&gt;
      &lt;name&gt;fs.default.name&lt;/name&gt;
      &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;
   &lt;/property&gt;
&lt;/configuration&gt;
</pre>
<p><b>hdfs-site.xml</b></p>
<p>The <b>hdfs-site.xml</b> file contains information such as the value of replication data, namenode path, and datanode paths of your local file systems. It means the place where you want to store the Hadoop infrastructure.</p>
<p>Let us assume the following data.</p>
<pre class="result notranslate">
dfs.replication (data replication value) = 1

(In the below given path /hadoop/ is the user name.
hadoopinfra/hdfs/namenode is the directory created by hdfs file system.)
namenode path = //home/hadoop/hadoopinfra/hdfs/namenode

(hadoopinfra/hdfs/datanode is the directory created by hdfs file system.)
datanode path = //home/hadoop/hadoopinfra/hdfs/datanode
</pre>
<p>Open this file and add the following properties in between the &lt;configuration&gt; &lt/configuration&gt; tags in this file.</p>
<pre class="result notranslate">
&lt;configuration&gt;
   &lt;property&gt;
      &lt;name&gt;dfs.replication&lt;/name&gt;
      &lt;value&gt;1&lt;/value&gt;
   &lt;/property&gt;

   &lt;property&gt;
      &lt;name&gt;dfs.name.dir&lt;/name&gt;
      &lt;value&gt;file:///home/hadoop/hadoopinfra/hdfs/namenode &lt;/value&gt;
   &lt;/property&gt;

   &lt;property&gt;
      &lt;name&gt;dfs.data.dir&lt/name&gt;
      &lt;value&gt;file:///home/hadoop/hadoopinfra/hdfs/datanode &lt;/value&gt;
   &lt;/property&gt;
&lt;/configuration&gt;
</pre>
<p><b>Note</b> &minus; In the above file, all the property values are user-defined and you can make changes according to your Hadoop infrastructure.</p>
<p><b>yarn-site.xml</b></p>
<p>This file is used to configure yarn into Hadoop. Open the yarn-site.xml file and add the following properties in between the &lt;configuration&gt;, &lt;/configuration&gt; tags in this file.</p>
<pre class="result notranslate">
&lt;configuration&gt;
   &lt;property&gt;
      &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
      &lt;value&gt;mapreduce_shuffle&lt/value&gt;
   &lt;/property&gt;
&lt;/configuration&gt;
</pre>
<p><b>mapred-site.xml</b></p>
<p>This file is used to specify which MapReduce framework we are using. By default, Hadoop contains a template of yarn-site.xml. First of all, it is required to copy the file from <b>mapred-site.xml.template</b> to <b> mapred-site.xml</b> file using the following command.</p>
<pre class="result notranslate">
$ cp mapred-site.xml.template mapred-site.xml
</pre>
<p>Open <b>mapred-site.xml</b> file and add the following properties in between the &lt;configuration&gt;, &lt;/configuration&gt;tags in this file.</p>
<pre class="result notranslate">
&lt;configuration&gt;
   &lt;property&gt;
      &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
      &lt;value&gt;yarn&lt;/value&gt;
   &lt;/property&gt;
&lt;/configuration&gt;
</pre>
<h2>Verifying Hadoop Installation</h2>
<p>The following steps are used to verify the Hadoop installation.</p>
<h3>Step 1 &minus; Name Node Setup</h3>
<p>Set up the namenode using the command “hdfs namenode -format” as follows.</p>
<pre class="result notranslate">
$ cd ~
$ hdfs namenode -format
</pre>
<p>The expected result is as follows.</p>
<pre class="result notranslate">
10/24/14 21:30:55 INFO namenode.NameNode: STARTUP_MSG:
/************************************************************
STARTUP_MSG: Starting NameNode
STARTUP_MSG:   host = localhost/192.168.1.11
STARTUP_MSG:   args = [-format]
STARTUP_MSG:   version = 2.4.1
...
...
10/24/14 21:30:56 INFO common.Storage: Storage directory
/home/hadoop/hadoopinfra/hdfs/namenode has been successfully formatted.
10/24/14 21:30:56 INFO namenode.NNStorageRetentionManager: Going to
retain 1 images with txid >= 0
10/24/14 21:30:56 INFO util.ExitUtil: Exiting with status 0
10/24/14 21:30:56 INFO namenode.NameNode: SHUTDOWN_MSG:
/************************************************************
SHUTDOWN_MSG: Shutting down NameNode at localhost/192.168.1.11
************************************************************/
</pre>
<h3>Step 2 &minus; Verifying Hadoop dfs</h3>
<p>The following command is used to start dfs. Executing this command will start your Hadoop file system.</p>
<pre class="result notranslate">
$ start-dfs.sh
</pre>
<p>The expected output is as follows &minus;</p>
<pre class="result notranslate">
10/24/14 21:37:56
Starting namenodes on [localhost]
localhost: starting namenode, logging to /home/hadoop/hadoop
2.4.1/logs/hadoop-hadoop-namenode-localhost.out
localhost: starting datanode, logging to /home/hadoop/hadoop
2.4.1/logs/hadoop-hadoop-datanode-localhost.out
Starting secondary namenodes [0.0.0.0]
</pre>
<h3>Step 3 &minus; Verifying Yarn Script</h3>
<p>The following command is used to start the yarn script. Executing this command will start your yarn daemons.</p>
<pre class="result notranslate">
$ start-yarn.sh
</pre>
<p>The expected output as follows &minus;</p>
<pre class="result notranslate">
starting yarn daemons
starting resourcemanager, logging to /home/hadoop/hadoop
2.4.1/logs/yarn-hadoop-resourcemanager-localhost.out
localhost: starting nodemanager, logging to /home/hadoop/hadoop
2.4.1/logs/yarn-hadoop-nodemanager-localhost.out
</pre>
<h3>Step 4 &minus; Accessing Hadoop on Browser</h3>
<p>The default port number to access Hadoop is 50070. Use the following url to get Hadoop services on browser.</p>
<pre class="result notranslate">
http://localhost:50070/
</pre>
<p></p>
<img src="{% static 'clever/img/bg-img/hadon.jpg' %}" alt="Accessing Hadoop on Browser" />
<h3>Step 5 &minus; Verify All Applications for Cluster</h3>
<p>The default port number to access all applications of cluster is 8088. Use the following url to visit this service.</p>
<pre class="result notranslate">
http://localhost:8088/
</pre>
<p></p>
<img src="{% static 'clever/img/bg-img/hadoop-ap.jpg' %}" alt="Hadoop Application Cluster" />

          </div>
             <div class="p5" style="border:solid 0px;height:7000px;display:none">
             <center> <h1>Hadoop HDFS Overview</h1></center>
<p>Hadoop File System was developed using distributed file system design. It is run on commodity hardware. Unlike other distributed systems, HDFS is highly faulttolerant and designed using low-cost hardware.</p>
<p>HDFS holds very large amount of data and provides easier access. To store such huge data, the files are stored across multiple machines. These files are stored in redundant fashion to rescue the system from possible data losses in case of failure. HDFS also makes applications available to parallel processing.</p>
<h2>Features of HDFS</h2>
<ul class="list">
<li>It is suitable for the distributed storage and processing.</li>
<li>Hadoop provides a command interface to interact with HDFS.</li>
<li>The built-in servers of namenode and datanode help users to easily check the status of cluster.</li>
<li>Streaming access to file system data.</li>
<li>HDFS provides file permissions and authentication.</li>
</ul>
<h2>HDFS Architecture</h2>
<p>Given below is the architecture of a Hadoop File System.</p>
<img src="{% static 'clever/img/bg-img/hdfs.jpg' %}" alt="HDFS Architecture" />
<p>HDFS follows the master-slave architecture and it has the following elements. </p>
<h3>Namenode</h3>
<p>The namenode is the commodity hardware that contains the GNU/Linux operating system and the namenode software. It is a software that can be run on commodity hardware. The system having the namenode acts as the master server and it does the following tasks &minus;</p>
<ul class="list">
<li><p>Manages the file system namespace.</p></li>
<li><p>Regulates client’s access to files.</p></li>
<li><p>It also executes file system operations such as renaming, closing, and opening files and directories.</p></li>
</ul>
<h3>Datanode</h3>
<p>The datanode is a commodity hardware having the GNU/Linux operating system and datanode software. For every node (Commodity hardware/System) in a cluster, there will be a datanode. These nodes manage the data storage of their system.</p>
<ul class="list">
<li><p>Datanodes perform read-write operations on the file systems, as per client request.</p></li>
<li><p>They also perform operations such as block creation, deletion, and replication according to the instructions of the namenode.</p></li>
</ul>
<h3>Block</h3>
<p>Generally the user data is stored in the files of HDFS. The file in a file system will be divided into one or more segments and/or stored in individual data nodes. These file segments are called as blocks. In other words, the minimum amount of data that HDFS can read or write is called a Block. The default block size is 64MB, but it can be increased as per the need to change in HDFS configuration.</p>
<h2>Goals of HDFS</h2>
<p><b>Fault detection and recovery</b> &minus; Since HDFS includes a large number of commodity hardware, failure of components is frequent. Therefore HDFS should have mechanisms for quick and automatic fault detection and recovery.</p>
<p><b>Huge datasets</b> &minus; HDFS should have hundreds of nodes per cluster to manage the applications having huge datasets.</p>
<p><b>Hardware at data</b> &minus; A requested task can be done efficiently, when the computation takes place near the data. Especially where huge datasets are involved, it reduces the network traffic and increases the throughput.</p>
             </div>

            <div class="p6" style="border:solid 0px;height:2500px;display:none">
             <center> <h1>Hadoop HDFS Operation</h1></center>
<h2>Starting HDFS</h2>
<p>Initially you have to format the configured HDFS file system, open namenode (HDFS server), and execute the following command.</p>
<pre class="result notranslate">
$ hadoop namenode -format
</pre>
<p>After formatting the HDFS, start the distributed file system. The following command will start the namenode as well as the data nodes as cluster.</p>
<pre class="result notranslate">
$ start-dfs.sh
</pre>
<h2>Listing Files in HDFS</h2>
<p>After loading the information in the server, we can find the list of files in a directory, status of a file, using <b>‘ls’</b>. Given below is the syntax of <b>ls</b> that you can pass to a directory or a filename as an argument.</p>
<pre class="result notranslate">
$ $HADOOP_HOME/bin/hadoop fs -ls &lt;args&gt;
</pre>
<h2>Inserting Data into HDFS</h2>
<p>Assume we have data in the file called file.txt in the local system which is ought to be saved in the hdfs file system. Follow the steps given below to insert the required file in the Hadoop file system.</p>
<h3>Step 1</h3>
<p>You have to create an input directory.</p>
<pre class="result notranslate">
$ $HADOOP_HOME/bin/hadoop fs -mkdir /user/input
</pre>
<h3>Step 2</h3>
<p>Transfer and store a data file from local systems to the Hadoop file system using the put command.</p>
<pre class="result notranslate">
$ $HADOOP_HOME/bin/hadoop fs -put /home/file.txt /user/input
</pre>
<h3>Step 3</h3>
<p>You can verify the file using ls command.</p>
<pre class="result notranslate">
$ $HADOOP_HOME/bin/hadoop fs -ls /user/input
</pre>
<h2>Retrieving Data from HDFS</h2>
<p>Assume we have a file in HDFS called <b>outfile</b>. Given below is a simple demonstration for retrieving the required file from the Hadoop file system.</p>
<h3>Step 1</h3>
<p>Initially, view the data from HDFS using <b>cat</b> command.</p>
<pre class="result notranslate">
$ $HADOOP_HOME/bin/hadoop fs -cat /user/output/outfile
</pre>
<h3>Step 2</h3>
<p>Get the file from HDFS to the local file system using <b>get</b> command.</p>
<pre class="result notranslate">
$ $HADOOP_HOME/bin/hadoop fs -get /user/output/ /home/hadoop_tp/
</pre>
<h2>Shutting Down the HDFS</h2>
<p>You can shut down the HDFS by using the following command.</p>
<pre class="result notranslate">
$ stop-dfs.sh
</pre>
            </div>

            <div class="p7" style="border:solid 0px;height:2500px;display:none">
             <center> <h1>Hadoop Command Reference</h1></center>
<p>There are many more commands in <b>"$HADOOP_HOME/bin/hadoop fs"</b> than are demonstrated here, although these basic operations will get you started. Running ./bin/hadoop dfs with no additional arguments will list all the commands that can be run with the FsShell system. Furthermore, <b>$HADOOP_HOME/bin/hadoop fs -help </b> commandName will display a short usage summary for the operation in question, if you are stuck.</p>
<p>A table of all the operations is shown below. The following conventions are used for parameters &minus;</p>
<pre class="result notranslate">
"&lt;path&gt;" means any file or directory name.
"&lt;path&gt;..." means one or more file or directory names.
"&lt;file&gt;" means any filename.
"&lt;src&gt;" and "&lt;dest&gt;" are path names in a directed operation.
"&lt;localSrc&gt;" and "&lt;localDest&gt;" are paths as above, but on the local file system.
</pre>
<p>All other files and path names refer to the objects inside HDFS.</p>
<table class="table table-bordered">
<tr>
<th>Sr.No</th>
<th style="text-align:center;">Command &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>-ls &lt;path&gt;</b></p>
<p>Lists the contents of the directory specified by path, showing the names, permissions, owner, size and modification date for each entry.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>-lsr &lt;path&gt;</b></p>
<p>Behaves like -ls, but recursively displays entries in all subdirectories of path.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>-du &lt;path&gt;</b></p>
<p>Shows disk usage, in bytes, for all the files which match path; filenames are reported with the full HDFS protocol prefix.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>-dus &lt;path&gt;</b></p>
<p>Like -du, but prints a summary of disk usage of all files/directories in the path.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>-mv &lt;src&gt;&lt;dest&gt;</b></p>
<p>Moves the file or directory indicated by src to dest, within HDFS.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>-cp &lt;src&gt; &lt;dest&gt;</b></p>
<p>Copies the file or directory identified by src to dest, within HDFS.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><p><b>-rm &lt;path&gt;</b></p>
<p>Removes the file or empty directory identified by path.</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><p><b>-rmr &lt;path&gt;</b></p>
<p>Removes the file or directory identified by path. Recursively deletes any child entries (i.e., files or subdirectories of path).</p></td>
</tr>
<tr>
<td class="ts">9</td>
<td><p><b>-put &lt;localSrc&gt; &lt;dest&gt;</b></p>
<p>Copies the file or directory from the local file system identified by localSrc to dest within the DFS.</p></td>
</tr>
<tr>
<td class="ts">10</td>
<td><p><b>-copyFromLocal &lt;localSrc&gt; &lt;dest&gt;</b></p>
<p>Identical to -put</p></td>
</tr>
<tr>
<td class="ts">11</td>
<td><p><b>-moveFromLocal &lt;localSrc&gt; &lt;dest&gt;</b></p>
<p>Copies the file or directory from the local file system identified by localSrc to dest within HDFS, and then deletes the local copy on success.</p></td>
</tr>
<tr>
<td class="ts">12</td>
<td><p><b>-get [-crc] &lt;src&gt; &lt;localDest&gt;</b></p>
<p>Copies the file or directory in HDFS identified by src to the local file system path identified by localDest.</p></td>
</tr>
<tr>
<td class="ts">13</td>
<td><p><b>-getmerge &lt;src&gt; &lt;localDest&gt;</b></p>
<p>Retrieves all files that match the path src in HDFS, and copies them to a single, merged file in the local file system identified by localDest.</p></td>
</tr>
<tr>
<td class="ts">14</td>
<td><p><b>-cat &lt;filen-ame&gt;</b></p>
<p>Displays the contents of filename on stdout.</p></td>
</tr>
<tr>
<td class="ts">15</td>
<td><p><b>-copyToLocal &lt;src&gt; &lt;localDest&gt;</b></p>
<p>Identical to -get</p></td>
</tr>
<tr>
<td class="ts">16</td>
<td><p><b>-moveToLocal &lt;src&gt; &lt;localDest&gt;</b></p>
<p>Works like -get, but deletes the HDFS copy on success.</p></td>
</tr>
<tr>
<td class="ts">17</td>
<td><p><b>-mkdir &lt;path&gt;</b></p>
<p>Creates a directory named path in HDFS.</p>
<p>Creates any parent directories in path that are missing (e.g., mkdir -p in Linux).</p>
</td>
</tr>
<tr>
<td class="ts">18</td>
<td><p><b>-setrep [-R] [-w] rep &lt;path&gt;</b></p>
<p>Sets the target replication factor for files identified by path to rep. (The actual replication factor will move toward the target over time)</p></td>
</tr>
<tr>
<td class="ts">19</td>
<td><p><b>-touchz &lt;path&gt;</b></p>
<p>Creates a file at path containing the current time as a timestamp. Fails if a file already exists at path, unless the file is already size 0.</p></td>
</tr>
<tr>
<td class="ts">20</td>
<td><p><b>-test -[ezd] &lt;path&gt;</b></p>
<p>Returns 1 if path exists; has zero length; or is a directory or 0 otherwise.</p></td>
</tr>
<tr>
<td class="ts">21</td>
<td><p><b>-stat [format] &lt;path&gt;</b></p>
<p>Prints information about path. Format is a string which accepts file size in blocks (%b), filename (%n), block size (%o), replication (%r), and modification date (%y, %Y).</p></td>
</tr>
<tr>
<td class="ts">22</td>
<td><p><b>-tail [-f] &lt;file2name&gt;</b></p>
<p>Shows the last 1KB of file on stdout.</p></td>
</tr>
<tr>
<td class="ts">23</td>
<td><p><b>-chmod [-R] mode,mode,... &lt;path&gt;...</b></p>
<p>Changes the file permissions associated with one or more objects identified by path.... Performs changes recursively with R. mode is a 3-digit octal mode, or {augo}+/-{rwxX}. Assumes if no scope is specified and does not apply an umask.</p></td>
</tr>
<tr>
<td class="ts">24</td>
<td><p><b>-chown [-R] [owner][:[group]] &lt;path&gt;...</b></p>
<p>Sets the owning user and/or group for files or directories identified by path.... Sets owner recursively if -R is specified.</p></td>
</tr>
<tr>
<td class="ts">25</td>
<td><p><b>-chgrp [-R] group &lt;path&gt;...</b></p>
<p>Sets the owning group for files or directories identified by path.... Sets group recursively if -R is specified.</p></td>
</tr>
<tr>
<td class="ts">26</td>
<td><p><b>-help &lt;cmd-name&gt;</b></p>
<p>Returns usage information for one of the commands listed above. You must omit the leading '-' character in cmd.</p></td>
</tr>
</table>
 </div>
        </div><!--  6 div close --->

    <div class="col-md-3 bll"></div>
</div>
</div>
</body>
{% include 'clever/footer.html'%}
<!-- jQuery-2.2.4 js -->
    <script src="{% static 'clever/js/jquery/jquery-2.2.4.min.js' %}"></script>
    <!-- Popper js -->
    <script src="{% static 'clever/js/bootstrap/popper.min.js' %}"></script>
    <!-- Bootstrap js -->
    <script src="{% static 'clever/js/bootstrap/bootstrap.min.js' %}"></script>
    <!-- All Plugins js -->
    <script src="{% static 'clever/js/plugins/plugins.js' %}"></script>
    <!-- Active js -->
    <script src="{% static 'clever/js/active.js' %}"></script>
</html>